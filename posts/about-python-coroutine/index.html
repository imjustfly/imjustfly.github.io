<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
    <title>理解Python协程的本质 - mdhs.me</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	=============<br>
	== <a href="https://mdhs.me/">mdhs.me</a> ==<br>
    =============
	<div style="float: right;">mdhs is short for _毛豆花生.</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>文章[Posts]</b></a>.
			
			<a href="/categories/"><b>分类[categories]</b></a>.
			
			<a href="/tags/"><b>标签[Tags]</b></a>.
			
			<a href="/about/"><b>关于[About]</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>理解Python协程的本质</h1>
			<b><time>2020.12.04 20:36</time></b>
		       
		           <a href="/tags/python">python</a>
        	       
		           <a href="/tags/asyncio">asyncio</a>
        	       

			<div>
				<p>这两天因为一点个人原因写了点好久没碰的python，其中涉及到协程编程，上次搞的时候，它还是web框架<code>tornado</code>特有的feature，现在已经有<code>async</code> <code>await</code> 关键字支持了。思考了一下其实现，回顾了下这些年的演变，觉得还有点意思。</p>
<blockquote>
<p>都是单线程，为什么原来低效率的代码用了<code>async</code> <code>await</code>加一些异步库就变得效率高了？</p>
</blockquote>
<p>如果你做基于python的网络或者web开发时，对于这个问题曾感到疑惑，这篇文章会给你答案。</p>
<h2 id="0x00-开始之前">0x00 开始之前</h2>
<p>首先，本文<strong>不是带你浏览源代码</strong>，然后对照原始代码给你讲python标准的实现。相反，我们会从实际问题出发，思考解决问题的方案，一步步体会解决方案的演进路径，最重要的，希望能在过程中获得知识系统性提升。</p>
<p><strong>⚠️ 本文仅是提供此了一个独立的思考方向，并未遵循历史和现有实际具体的实现细节。</strong></p>
<p>其次，阅读这篇文章需要你对python比较熟悉，至少了解python中的生成器<code>generator</code>的概念。</p>
<h2 id="0x01-io-多路复用">0x01 IO 多路复用</h2>
<p>这是性能的关键。但我们这里只解释概念，其实现细节不是重点，这对我们理解python的协程已经足够了，如已足够了解，前进到<code>0x02</code>。</p>
<p>首先，你要知道所有的网络服务程序都是一个巨大的死循环，你的业务逻辑都在这个循环的某个时刻被调用：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">handler</span>(<span style="color:#000">request</span>):
    <span style="color:#888;font-style:italic"># 处理请求</span>
    <span style="color:#00f">pass</span>

<span style="color:#888;font-style:italic"># 你的 handler 运行在 while 循环中</span>
<span style="color:#00f">while</span> <span style="color:#000">True</span>:
    <span style="color:#888;font-style:italic"># 获取一个新请求</span>
    <span style="color:#000">request</span> = <span style="color:#000">accept</span>()
    <span style="color:#888;font-style:italic"># 根据路由映射获取到用户写的业务逻辑函数</span>
    <span style="color:#000">handler</span> = <span style="color:#000">get_handler</span>(<span style="color:#000">request</span>)
    <span style="color:#888;font-style:italic"># 运行用户的handler，处理请求</span>
    <span style="color:#000">handler</span>(<span style="color:#000">request</span>)
</code></pre></td></tr></table>
</div>
</div><p>设想你的web服务的某个<code>handler</code>，在接收到请求后需要一个api调用才能响应结果。对于最传统的网络应用，你的api请求发出去后在等待响应，此时程序停止运行，甚至新的请求也得在响应结束后才进得来。如果你依赖的API请求网络丢包严重，响应特别慢呢？那应用的吞吐量将非常低。</p>
<p>很多传统web服务器使用多线程技术解决这个问题：把<code>handler</code>的运行放到其他线程上，每个线程处理一个请求，本线程阻塞不影响新请求进入。这能一定程度上解决问题，但对于并发比较大的系统，过多线程调度会带来很大的性能开销。</p>
<p>IO多路复用可以做到不使用线程解决问题，它是由操作系统内核提供的功能，可以说专门为这类场景而生。简单来讲，你的程序遇到网络IO时，告诉操作系统帮你盯着，同时操作系统提供给你一个方法，让你可以随时获取到有哪些io操作已经完成。就像这样：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#888;font-style:italic"># 操作系统的IO复用示例伪代码</span>
<span style="color:#000">io_register</span>(<span style="color:#000">io_id</span>, <span style="color:#000">io_type</span>)  <span style="color:#888;font-style:italic"># 向操作系统io注册自己关注的io操作的id和类型</span>
<span style="color:#000">io_register</span>(<span style="color:#000">io_id</span>, <span style="color:#000">io_type</span>)
<span style="color:#888;font-style:italic"># 获取完成的io操作, 使用 epoll() in Linux and kqueue() in Unix</span>
<span style="color:#000">events</span> = <span style="color:#000">io_get_finished</span>()

<span style="color:#00f">for</span> (<span style="color:#000">io_id</span>, <span style="color:#000">io_type</span>) <span style="color:#00f">in</span> <span style="color:#000">events</span>:
    <span style="color:#00f">if</span> <span style="color:#000">io_type</span> == <span style="color:#000">READ</span>:
        <span style="color:#000">data</span> = <span style="color:#000">read_data</span>(<span style="color:#000">io_id</span>)
    <span style="color:#00f">elif</span> <span style="color:#000">io_type</span> == <span style="color:#000">WRITE</span>:
        <span style="color:#000">write_data</span>(<span style="color:#000">io_id</span><span style="color:#f00">，</span><span style="color:#000">data</span>)
</code></pre></td></tr></table>
</div>
</div><p>把IO复用逻辑融合到我们的服务器中，大概会像这样：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">call_backs</span> = {}

<span style="color:#00f">def</span> <span style="color:#000">handler</span>(<span style="color:#000">req</span>):
    <span style="color:#888;font-style:italic"># do jobs here</span>
    <span style="color:#000">io_register</span>(<span style="color:#000">io_id</span>, <span style="color:#000">io_type</span>)
    <span style="color:#00f">def</span> <span style="color:#000">call_back</span>(<span style="color:#000">result</span>):
    <span style="color:#888;font-style:italic"># 使用返回的result完成剩余工作</span>
    <span style="color:#000">call_backs</span>[<span style="color:#000">io_id</span>] = <span style="color:#000">call_back</span>

<span style="color:#888;font-style:italic"># 新的循环</span>
<span style="color:#00f">while</span> <span style="color:#000">True</span><span style="color:#f00">：</span>
    <span style="color:#888;font-style:italic"># 获取已经完成的io事件</span>
    <span style="color:#000">events</span> = <span style="color:#000">io_get_finished</span>()
    <span style="color:#00f">for</span> (<span style="color:#000">io_id</span>, <span style="color:#000">io_type</span>) <span style="color:#00f">in</span> <span style="color:#000">events</span>:
        <span style="color:#00f">if</span> <span style="color:#000">io_type</span> == <span style="color:#000">READ</span>: <span style="color:#888;font-style:italic"># 读取</span>
            <span style="color:#000">data</span> = <span style="color:#000">read</span>(<span style="color:#000">io_id</span>)
            <span style="color:#000">call_back</span> = <span style="color:#000">call_backs</span>[<span style="color:#000">io_id</span>]
            <span style="color:#000">call_back</span>(<span style="color:#000">data</span>)
        <span style="color:#00f">else</span>:
            <span style="color:#888;font-style:italic"># 其他类型io事件的处理</span>
            <span style="color:#00f">pass</span>

    <span style="color:#888;font-style:italic"># 获取一个新请求</span>
    <span style="color:#000">request</span> = <span style="color:#000">accept</span>()
    <span style="color:#888;font-style:italic"># 根据路由映射获取到用户写的业务逻辑函数</span>
    <span style="color:#000">handler</span> = <span style="color:#000">get_handler</span>(<span style="color:#000">request</span>)
    <span style="color:#888;font-style:italic"># 运行用户的handler，处理请求</span>
    <span style="color:#000">handler</span>(<span style="color:#000">request</span>)
</code></pre></td></tr></table>
</div>
</div><p>我们的handler对于IO操作，注册了回调就立刻返回，同时每次迭代都会对已完成的IO执行回调，网络请求不再阻塞整个服务器。</p>
<p>上面的伪代码仅便于理解，具体实现细节更复杂。而且就连接受新请求也是在从操作系统得到监听端口的IO事件后进行的。我们如果把循环部分还有<code>call_backs</code>字典拆分到单独模块，就能得到一个<code>EventLoop</code>，也就是python标准库 <code>asyncio</code>包中提供的<code>ioloop</code></p>
<h2 id="0x02-用生成器消除-callback">0x02 用生成器消除 callback</h2>
<p>着重看下我们业务中经常写的handler函数，在有独立的ioloop后，它现在变成类似这样：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">handler</span>(<span style="color:#000">request</span>):
    <span style="color:#888;font-style:italic"># 业务逻辑代码</span>

    <span style="color:#888;font-style:italic"># 需要执行一次API请求</span>
    <span style="color:#00f">def</span> <span style="color:#000">call_back</span>(<span style="color:#000">result</span>):
        <span style="color:#888;font-style:italic"># 使用API返回的result完成剩余工作</span>
        <span style="color:#00f">print</span>(<span style="color:#000">result</span>)
    <span style="color:#888;font-style:italic"># 注册回调，没有io_call这个方法，仅示意，表示注册一个io操作</span>
    <span style="color:#000">asyncio</span>.<span style="color:#000">get_event_loop</span>().<span style="color:#000">io_call</span>(<span style="color:#000">api</span>, <span style="color:#000">call_back</span>)
</code></pre></td></tr></table>
</div>
</div><p>到这里，性能问题已经解决了：我们不再需要多线程就能源源不断接受新请求，而且不用care依赖的API响应有多慢。</p>
<p>但是我们也引入了一个新问题，原来流畅的业务逻辑代码现在被拆成了两部分，请求API之前的代码还正常，请求API之后的代码只能写在回调函数里面了。这里我们业务逻辑只有一个API调用，如果有多个API，再加上对redis或者mysql的调用（它们本质也是网络请求），整个逻辑会被拆分的更散，这对业务开发是一笔负担。对于有匿名函数的一些语言（没错就是javascript），还可能会引发所谓的「回调地狱」。接下来我们想办法解决这个问题。</p>
<blockquote>
<p>如果函数在运行到网络IO操作处后能够暂停，完成后又能在断点处唤醒就好了。</p>
</blockquote>
<p>如果你对python的<strong>生成器</strong>熟悉，你应该会发现，它恰好具有这个功能：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">example</span>():
    <span style="color:#000">value</span> = <span style="color:#00f">yield</span> <span style="color:#3af">2</span>
    <span style="color:#00f">print</span>(<span style="color:#5a2">&#34;get&#34;</span>, <span style="color:#000">value</span>)
    <span style="color:#00f">return</span> <span style="color:#000">value</span>

<span style="color:#000">g</span> = <span style="color:#000">example</span>()
<span style="color:#888;font-style:italic"># 使用send(None)启动生成器，我们应该会得到 2</span>
<span style="color:#000">got</span> = <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">None</span>)
<span style="color:#00f">print</span>(<span style="color:#000">got</span>)  <span style="color:#888;font-style:italic"># 2</span>

<span style="color:#00f">try</span>:
    <span style="color:#888;font-style:italic"># 再次启动 会显示 &#34;get 4&#34;, 就是我们传入的值</span>
    <span style="color:#000">got</span> = <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">got</span>*<span style="color:#3af">2</span>)
<span style="color:#00f">except</span> <span style="color:#000">StopIteration</span> <span style="color:#00f">as</span> <span style="color:#000">e</span>:
    <span style="color:#888;font-style:italic"># 生成器运行完成，将会print(4)，e.value 是生成器return的值</span>
    <span style="color:#00f">print</span>(<span style="color:#000">e</span>.<span style="color:#000">value</span>)
</code></pre></td></tr></table>
</div>
</div><p>函数中有<code>yield</code>关键字，调用函数将会得到一个生成器，生成器一个关键的方法<code>send()</code>可以跟生成器交互。<code>g.send(None)</code> 会运行生成器内代码直到遇到<code>yield</code>，并返回其后的对象，也就是<code>2</code>，生成器代码就停在这里了，直到我们再次执行<code>g.send(got*2)</code>,会把<code>2*2</code>也就是<code>4</code> 赋值给<code>yield</code>前面的变量<code>value</code>,然后继续运行生成器代码。 <strong>yield在这里就像一扇门，可以把一件东西从这里送出去，也可以把另一件东西拿进来。</strong></p>
<p>如果<code>send</code>让生成器运行到下一个<code>yield</code>前就结束了，send调用会引发一个特殊的异常<code>StopIteration</code>，这个异常自带一个属性<code>value</code>，为生成器return的值。</p>
<p>如果我们把我们的<code>handler</code>用<code>yield</code>关键字转换成一个生成器，运行它来把<strong>IO操作的具体内容</strong>返回，IO完成后的回调函数中把IO结果放回并恢复生成器运行，那就解决了业务代码不流畅的问题了：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">handler</span>(<span style="color:#000">request</span>):
    <span style="color:#888;font-style:italic"># 业务逻辑代码</span>

    <span style="color:#888;font-style:italic"># 需要执行一次API请求，直接把IO请求信息yield出去</span>
    <span style="color:#000">result</span> = <span style="color:#00f">yield</span> <span style="color:#000">io_info</span>
    <span style="color:#888;font-style:italic"># 使用API返回的result完成剩余工作</span>
    <span style="color:#00f">print</span>(<span style="color:#000">result</span>)

<span style="color:#888;font-style:italic"># 这个函数注册到ioloop中，用来当有新请求的时候回调</span>
<span style="color:#00f">def</span> <span style="color:#000">on_request</span>(<span style="color:#000">request</span>):
    <span style="color:#888;font-style:italic"># 根据路由映射获取到用户写的业务逻辑函数</span>
    <span style="color:#000">handler</span> = <span style="color:#000">get_handler</span>(<span style="color:#000">request</span>)
    <span style="color:#000">g</span> = <span style="color:#000">handler</span>(<span style="color:#000">request</span>)
    <span style="color:#888;font-style:italic"># 首次启动获得io_info</span>
    <span style="color:#000">io_info</span> = <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">None</span>)

    <span style="color:#888;font-style:italic"># io完成回调函数</span>
    <span style="color:#00f">def</span> <span style="color:#000">call_back</span>(<span style="color:#000">result</span>):
        <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">result</span>)  <span style="color:#888;font-style:italic"># 重新启动生成器</span>

    <span style="color:#000">asyncio</span>.<span style="color:#000">get_event_loop</span>().<span style="color:#000">io_call</span>(<span style="color:#000">io_info</span>, <span style="color:#000">call_back</span>)
</code></pre></td></tr></table>
</div>
</div><p>上面的例子，用户写的<code>handler</code>代码已经不会被打散到callback 中，<code>on_request</code>函数使用callback和<code>ioloop</code>交互，但它会被实现在web框架中，对用户不可见。上面代码足以给我们提供用生成器消灭的callback的启发，但局限性有两点：</p>
<ol>
<li>业务逻辑中仅发起一次网络IO，但实际中往往更多</li>
<li>业务逻辑没有调用其他异步函数（协程），但实际中我们往往会调用其他协程</li>
</ol>
<h2 id="0x03-解决完整调用链">0x03 解决完整调用链</h2>
<p>我们来看一个更复杂的例子：</p>
<p>函数调用链路图。</p>
<p>其中<code>request</code> 执行真正的IO，<code>func1</code> <code>func2</code> 仅调用。显然我们的代码只能写成这样：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">func1</span>():
    <span style="color:#000">ret</span> = <span style="color:#00f">yield</span> <span style="color:#000">request</span>(<span style="color:#5a2">&#34;http://test.com/foo&#34;</span>)
    <span style="color:#000">ret</span> = <span style="color:#00f">yield</span> <span style="color:#000">func2</span>(<span style="color:#000">ret</span>)
    <span style="color:#00f">return</span> <span style="color:#000">ret</span>

<span style="color:#00f">def</span> <span style="color:#000">func2</span>(<span style="color:#000">data</span>):
    <span style="color:#000">result</span> = <span style="color:#00f">yield</span> <span style="color:#000">request</span>(<span style="color:#5a2">&#34;http://test.com/&#34;</span>+<span style="color:#000">data</span>)
    <span style="color:#00f">return</span> <span style="color:#000">result</span>

<span style="color:#00f">def</span> <span style="color:#000">request</span>(<span style="color:#000">url</span>):
    <span style="color:#888;font-style:italic"># 这里模拟返回一个io操作，包含io操作的所有信息，这里用URL简化</span>
    <span style="color:#000">result</span> = <span style="color:#00f">yield</span> <span style="color:#5a2">&#34;iojob of </span><span style="color:#5a2">%s</span><span style="color:#5a2">&#34;</span> % <span style="color:#000">url</span>
    <span style="color:#00f">return</span> <span style="color:#000">result</span>
</code></pre></td></tr></table>
</div>
</div><p>对于<code>request</code>，我们把IO操作通过yield暴露给框架。<strong>对于<code>func1</code> 和 <code>func2</code>，调用<code>request</code>显然也要加<code>yield</code>关键字</strong>，否则<code>request</code>调用返回一个生成器后不会暂停，继续执行后续逻辑显然会出错。</p>
<p>这基本就是我们在没有<code>yield from</code> <code>aysnc</code> <code>await</code>时代，在tornado框架中写异步代码的样子。</p>
<p>要运行整个调用栈，大概流程如下：</p>
<ol>
<li>调用<code>func1()</code>得到生成器</li>
<li>调用<code>send(None)</code>启动它得到会得到<code>request(&quot;http://test.com/foo&quot;)</code>的结果，还是生成器对象</li>
<li><code>send(None)</code>启动由<code>request()</code>产生的生成器，会得到IO操作，由框架注册到ioloop并指定回调</li>
<li>IO完成后的回调函数内唤醒<code>request</code>生成器，生成器会走到<code>return</code>语句结束</li>
<li>捕获异常得到<code>request</code>生成器的返回值，将上一层<code>func1</code>唤醒，同时又得到<code>func2()</code>生成器</li>
<li>&hellip; 继续执行</li>
</ol>
<p>对算法和数据结构熟悉的朋友遇到这种前进后退的遍历逻辑，可以递归也可以用栈，因为递归使用生成器还做不到，我们可以使用栈，其实这就是「调用栈」一词的由来。</p>
<p>
<figure>
  <img src="/images/coroutine_stack.png" alt="coroutine in stack" />
</figure>


</p>
<p>借助栈，我们可以<strong>把整个调用链上串联的所有生成器对表现为一个生成器</strong>，对其不断send就能不断得到所有io操作信息并推动调用链前进，实现方法如下：</p>
<ol>
<li>第一个生成器入栈</li>
<li>调用<code>send</code>，如果得到生成器就入栈并进入下一轮迭代</li>
<li>遇到到IO请求<code>yield</code>出来，让框架注册到ioloop</li>
<li>IO操作完成后被唤醒，缓存结果并出栈，进入下一轮迭代，目的让上层函数使用IO结果恢复运行</li>
<li>如果一个生成器运行完毕，也需要和4一样让上层函数恢复运行</li>
</ol>
<p>如果实现出来，代码不长但信息量比较大。他把整个调用链对外变成一个生成器，对其调用send，就能整个调用链中的IO，完成这些IO，继续推动调用链内的逻辑执行，直到整体逻辑结束：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">wrapper</span>(<span style="color:#000">gen</span>):
    <span style="color:#888;font-style:italic"># 第一层调用 入栈</span>
    <span style="color:#000">stack</span> = <span style="color:#000">Stack</span>()
    <span style="color:#000">stack</span>.<span style="color:#000">push</span>(<span style="color:#000">gen</span>)

    <span style="color:#888;font-style:italic"># 开始逐层调用</span>
    <span style="color:#00f">while</span> <span style="color:#000">True</span>:
        <span style="color:#888;font-style:italic"># 获取栈顶元素</span>
        <span style="color:#000">item</span> = <span style="color:#000">stack</span>.<span style="color:#000">peak</span>()

        <span style="color:#000">result</span> = <span style="color:#000">None</span>
        <span style="color:#00f">if</span> <span style="color:#000">isgenerator</span>(<span style="color:#000">item</span>):  <span style="color:#888;font-style:italic"># 生成器，</span>
            <span style="color:#00f">try</span>:
                <span style="color:#888;font-style:italic"># 尝试获取下个生成器调用，并入栈</span>
                <span style="color:#888;font-style:italic"># result 初始为None，之后迭代中将为下层调用的返回值</span>
                <span style="color:#000">child</span> = <span style="color:#000">item</span>.<span style="color:#000">send</span>(<span style="color:#000">result</span>)
                <span style="color:#000">result</span> = <span style="color:#000">None</span>
                <span style="color:#000">stack</span>.<span style="color:#000">push</span>(<span style="color:#000">child</span>)
                <span style="color:#888;font-style:italic"># 入栈后直接进入下次循环，继续深入调用链</span>
                <span style="color:#00f">continue</span>
            <span style="color:#00f">except</span> <span style="color:#000">StopIteration</span> <span style="color:#00f">as</span> <span style="color:#000">e</span>:
                <span style="color:#888;font-style:italic"># 如果自己运行结束了，就暂存result，下一步让自己出栈</span>
                <span style="color:#000">result</span> = <span style="color:#000">e</span>.<span style="color:#000">value</span>
        <span style="color:#00f">else</span>:  <span style="color:#888;font-style:italic"># io 操作</span>
            <span style="color:#888;font-style:italic"># 遇到了io操作，yield出去</span>
            <span style="color:#888;font-style:italic"># IO完成后会被用IO结果唤醒并暂存到result</span>
            <span style="color:#000">result</span> = <span style="color:#00f">yield</span> <span style="color:#000">item</span>

        <span style="color:#888;font-style:italic"># 走到这里则本层已经执行完毕，出栈，下次迭代将回到调用链上一层</span>
        <span style="color:#000">stack</span>.<span style="color:#000">pop</span>()
        <span style="color:#888;font-style:italic"># 没有上一层的话，那整个调用链都执行完成了，return</span>
        <span style="color:#00f">if</span> <span style="color:#000">stack</span>.<span style="color:#000">empty</span>():
            <span style="color:#00f">print</span>(<span style="color:#5a2">&#34;finished&#34;</span>)
            <span style="color:#00f">return</span> <span style="color:#000">result</span>
</code></pre></td></tr></table>
</div>
</div><p>这可能是最复杂的部分，如果一下难以接受可以略过，对于本文理解无碍。只需要知道对于上面示例中的调用链，存在上面这种方法产生如下效果：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">w</span> = <span style="color:#000">wrapper</span>(<span style="color:#000">func1</span>())
<span style="color:#888;font-style:italic"># 启动 wrpper, 将会得到 &#34;iojob of http://test.com/foo&#34;</span>
<span style="color:#000">w</span>.<span style="color:#000">send</span>(<span style="color:#000">None</span>)
<span style="color:#888;font-style:italic"># 上个iojob foo 完成后的结果&#34;bar&#34;传入，继续运行，得到  &#34;iojob of http://test.com/bar&#34;</span>
<span style="color:#000">w</span>.<span style="color:#000">send</span>(<span style="color:#5a2">&#34;bar&#34;</span>)
<span style="color:#888;font-style:italic"># 上个iojob bar 完成后的结构&#34;barz&#34;传入，继续运行，结束。</span>
<span style="color:#000">w</span>.<span style="color:#000">send</span>(<span style="color:#5a2">&#34;barz&#34;</span>)
</code></pre></td></tr></table>
</div>
</div><p>有了这部分以后，框架只需要再加上配套的代码：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#888;font-style:italic"># 维护一个就绪列表，存放所有完成的IO事件，格式为（wrapper，result）</span>
<span style="color:#000">ready</span> = []

<span style="color:#00f">def</span> <span style="color:#000">on_request</span>(<span style="color:#000">request</span>):
    <span style="color:#000">handler</span> = <span style="color:#000">get_handler</span>(<span style="color:#000">request</span>)
    <span style="color:#888;font-style:italic"># 使用 wrapper 包装后，可以只通过send处理IO了</span>
    <span style="color:#000">g</span> = <span style="color:#000">wrapper</span>(<span style="color:#000">func1</span>())
    <span style="color:#888;font-style:italic"># 把开始状态直接视为结果为None的就绪状态</span>
    <span style="color:#000">ready</span>.<span style="color:#000">append</span>((<span style="color:#000">g</span>, <span style="color:#000">None</span>))

<span style="color:#888;font-style:italic"># 让ioloop每轮循环都执行此函数，用来处理的就绪的IO，</span>
<span style="color:#00f">def</span> <span style="color:#000">process_ready</span>(<span style="color:#000">self</span>):
    <span style="color:#00f">def</span> <span style="color:#000">call_back</span>(<span style="color:#000">g</span>, <span style="color:#000">result</span>):
        <span style="color:#000">ready</span>.<span style="color:#000">append</span>((<span style="color:#000">g</span>, <span style="color:#000">result</span>))

    <span style="color:#888;font-style:italic"># 遍历所有已经就绪生成器，将其向下推进</span>
    <span style="color:#00f">for</span> <span style="color:#000">g</span>, <span style="color:#000">result</span> <span style="color:#00f">in</span> <span style="color:#000">self</span>.<span style="color:#000">ready</span>:
        <span style="color:#888;font-style:italic"># 用result唤醒生成器，并得到下一个io操作</span>
        <span style="color:#000">io_job</span> = <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">result</span>)
        <span style="color:#000">asyncio</span>.<span style="color:#000">get_event_loop</span>().<span style="color:#000">io_call</span>(  <span style="color:#888;font-style:italic"># 注册io操作</span>
            <span style="color:#000">io_job</span>,
            <span style="color:#888;font-style:italic"># 完成后把生成器加入就绪列表，等待下一轮处理</span>
            <span style="color:#00f">lambda</span> <span style="color:#000">result</span>: <span style="color:#000">ready</span>.<span style="color:#000">append</span>((<span style="color:#000">g</span>, <span style="color:#000">result</span>)
        )

</code></pre></td></tr></table>
</div>
</div><p>这里核心思想是维护一个就绪列表，ioloop每轮迭代都来扫一遍，推动就绪的状态的生成器向下运行，并把新的到到IO操作注册，IO完成后再次加入就绪，经过几轮ioloop的迭代一个<code>handler</code>最终会被执行完成。</p>
<p>至此，我们使用生成器写法写业务逻辑已经可以正常运行。</p>
<h2 id="0x04-提高扩展性">0x04 提高扩展性</h2>
<p>如果到这里能读懂，python的协程原理基本就明白了。我们已经实现了一个微型的协程框架，标准库的实现细节跟这里看起来大不一样，但具体的思想是一致的。</p>
<p>我们的协程框架有一个限制，我们只能把IO操作异步化，虽然在网络编程和web编程的世界里，阻塞的基本只有IO操作，但也有一些例外，比如我想让当前操作<code>sleep</code>几秒，用<code>time.sleep()</code>又会让整个线程阻塞住，就需要特殊实现。再比如，可以把一些cpu密集的操作通过多线程异步化，让另一个线程通知事件已经完成后再执行后续。</p>
<p>所以，协程最好能与网络解耦开，让等待网络IO只是其中一种场景，提高扩展性。Python官方的解决方案是让用户自己处理阻塞代码，至于是向ioloop来注册IO事件还是开一个线程完全由你自己，并提供了一个标准「占位符」<code>Future</code>，表示他的结果等到未来才会有，其部分原型如下:</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">class</span> <span style="color:#000">Future</span><span style="color:#f00">：</span>
    <span style="color:#888;font-style:italic"># 设置结果</span>
    <span style="color:#00f">def</span> <span style="color:#000">set_result</span>(<span style="color:#000">result</span>): <span style="color:#00f">pass</span>
    <span style="color:#888;font-style:italic"># 获取结果</span>
    <span style="color:#00f">def</span> <span style="color:#000">result</span>():  <span style="color:#00f">pass</span>
    <span style="color:#888;font-style:italic"># 表示这个future对象是fou已被设置过结果</span>
    <span style="color:#00f">def</span> <span style="color:#000">done</span>(): <span style="color:#00f">pass</span>
    <span style="color:#888;font-style:italic"># 设置在他被设置结果时应该执行的回调函数，可以设置多个</span>
    <span style="color:#00f">def</span> <span style="color:#000">add_done_callback</span>(<span style="color:#000">callback</span>):  <span style="color:#00f">pass</span>
</code></pre></td></tr></table>
</div>
</div><p>我们的稍加改动就能支持future，让扩展性变得更强。对于用户代码的中的网络请求函数<code>request</code>：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#888;font-style:italic"># 现在 request 函数，不是生成器，它返回future</span>
<span style="color:#00f">def</span> <span style="color:#000">request</span>(<span style="color:#000">url</span>):
    <span style="color:#888;font-style:italic"># future 理解为占位符</span>
    <span style="color:#000">fut</span> = <span style="color:#000">Future</span>()

    <span style="color:#00f">def</span> <span style="color:#000">callback</span>(<span style="color:#000">result</span>):
        <span style="color:#888;font-style:italic"># 当网络IO完成回调的时候给占位符赋值</span>
        <span style="color:#000">fut</span>.<span style="color:#000">set_result</span>(<span style="color:#000">result</span>)
    <span style="color:#888;font-style:italic"># 注册回调</span>
    <span style="color:#000">asyncio</span>.<span style="color:#000">get_event_loop</span>().<span style="color:#000">io_call</span>(<span style="color:#000">url</span>, <span style="color:#000">callback</span>)

    <span style="color:#888;font-style:italic"># 返回占位符</span>
    <span style="color:#00f">return</span> <span style="color:#000">future</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，<code>request</code>不再是一个生成器，而是直接返回future。而对于位于框架中处理就绪列表的函数：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">def</span> <span style="color:#000">process_ready</span>(<span style="color:#000">self</span>):
    <span style="color:#00f">def</span> <span style="color:#000">callback</span>(<span style="color:#000">fut</span>):
        <span style="color:#888;font-style:italic"># future被设置结果会被放入就绪列表</span>
        <span style="color:#000">ready</span>.<span style="color:#000">append</span>((<span style="color:#000">g</span>, <span style="color:#000">fut</span>.<span style="color:#000">result</span>()))

    <span style="color:#888;font-style:italic"># 遍历所有已经就绪生成器，将其向下推进</span>
    <span style="color:#00f">for</span> <span style="color:#000">g</span>, <span style="color:#000">result</span> <span style="color:#00f">in</span> <span style="color:#000">self</span>.<span style="color:#000">ready</span>:
        <span style="color:#888;font-style:italic"># 用result唤醒生成器，得到的不再是io操作，而是future</span>
        <span style="color:#000">fut</span> = <span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">result</span>)
        <span style="color:#888;font-style:italic"># future被设置结果的时候会调用callback</span>
        <span style="color:#000">fut</span>.<span style="color:#000">add_done_callback</span>(<span style="color:#000">callback</span>)
</code></pre></td></tr></table>
</div>
</div><h2 id="0x05-发展和变革">0x05 发展和变革</h2>
<p>许多年前用<code>tornado</code>的时候，大概只有一个<code>yield</code>关键字可用，协程要想实现，就是这么个思路，甚至<code>yield</code>关键字和<code>return</code>关键字不能一个函数里面出现，你要想在生成器运行完后返回一个值，需要手动<code>raise</code>一个异常，虽然效果跟现在<code>return</code>一样，但写起来还是很别扭，不优雅。</p>
<p>后来有了<code>yield from</code> 表达式。他可以做什么？通俗地说，他就是做了上面那个生成器<code>wrapper</code>所做的事：通过栈实现调用链遍历的 ，<strong>它是<code>wrapper</code>逻辑的语法糖</strong>。有了它，同一个例子你可以这么写：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#00f">def</span> <span style="color:#000">func1</span>():
    <span style="color:#888;font-style:italic"># 注意 yield from</span>
    <span style="color:#000">ret</span> = <span style="color:#00f">yield</span> <span style="color:#00f">from</span> <span style="color:#000">request</span>(<span style="color:#5a2">&#34;http://test.com/foo&#34;</span>)
    <span style="color:#000">ret</span> = <span style="color:#00f">yield</span> <span style="color:#00f">from</span> <span style="color:#000">func2</span>(<span style="color:#000">ret</span>)
    <span style="color:#00f">return</span> <span style="color:#000">ret</span>

<span style="color:#00f">def</span> <span style="color:#000">func2</span>(<span style="color:#000">data</span>):
    <span style="color:#888;font-style:italic"># 注意 yield from</span>
    <span style="color:#000">result</span> = <span style="color:#00f">yield</span> <span style="color:#00f">from</span> <span style="color:#000">request</span>(<span style="color:#5a2">&#34;http://test.com/&#34;</span>+<span style="color:#000">data</span>)
    <span style="color:#00f">return</span> <span style="color:#000">result</span>

<span style="color:#00f">def</span> <span style="color:#000">request</span>(<span style="color:#000">url</span>):
    <span style="color:#888;font-style:italic"># 同上基于future实现的request</span>
    <span style="color:#00f">pass</span>
</code></pre></td></tr></table>
</div>
</div><p>然后你就不再需要那个烧脑的<code>wrapper</code>函数了，<code>yield from</code> 背后实现了那段晦涩的逻辑：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">g</span> = <span style="color:#000">func1</span>()
<span style="color:#888;font-style:italic"># 返回第一个请求的 future</span>
<span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#000">None</span>)
<span style="color:#888;font-style:italic"># 继续运行，进入func2 并得到第它里面的那个future</span>
<span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#5a2">&#34;bar&#34;</span>)
<span style="color:#888;font-style:italic"># 继续运行，完成调用链剩余逻辑，抛出StopIteration异常</span>
<span style="color:#000">g</span>.<span style="color:#000">send</span>(<span style="color:#5a2">&#34;barz&#34;</span>)
</code></pre></td></tr></table>
</div>
</div><p><code>yield from</code>直接打通了整个调用链，这已经算是很大的进步了，但是用来异步编程看着还是别扭，其他语言此时已经有专门的协程<code>async</code> <code>await</code>关键字了。终于，再后来的版本把这些内容进一步封装到的<code>async</code> <code>await</code> 关键字，才成为今天比较优雅的样子。</p>
<h2 id="0x06-总结和比较">0x06 总结和比较</h2>
<p>总的来说，python的原生的协程从两方面实现：</p>
<ol>
<li>基于IO多路复用技术，让整个应用在IO上非阻塞，实现高效率</li>
<li>通过生成器让分散的callback代码变成同步代码，减少业务编写困难</li>
</ol>
<p>有生成器这种对象的语言，其IO协程实现大抵如此，javascript协程的演进基本一模一样，关键字相同，<code>Future</code>类比<code>Promise</code>本质上区别不大。</p>
<p>但是对于以协程闻名的<code>go</code>语言，协程实现跟这个就不同了，它并不基于已有的生成器数据结构。如果要类比的话，可以勉强和python的<code>gevent</code>算作一类，都是自己实现runtime，并patch掉直接的系统调用接入自己的runtime，自己来调度协程，gevent专注于网络相关，基于网络IO调度，比较简单，go实现了完善的多核支持，调度更加复杂和完善，而且创造了基于<code>channel</code>新编程范式。</p>
<hr>
<p>以上。</p>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/about-python-coroutine/">理解Python协程的本质</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2020 <a href="https://mdhs.me/"><b>mdhs.me</b></a>.
	<a href="https://github.com/imjustfly"><b>Github</b></a>.
	<a href="https://twitter.com/justfly_ho"><b>Twitter</b></a>.
	</p>
</footer>

</body>
</html>
